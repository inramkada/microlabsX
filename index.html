<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>MicroretailX</title>

<style>
  html, body{
    margin:0; height:100%;
    background:#000; color:#fff;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    overflow-x:hidden;
  }
  html,body{scrollbar-width:none;-ms-overflow-style:none}
  ::-webkit-scrollbar{width:0;height:0}

  /* Background video */
  #bg{
    position:fixed; inset:0;
    width:100vw; height:100vh;
    object-fit:cover;
    z-index:1;
    pointer-events:none;
  }

  /* Topbar */
  .topbar{
    position:fixed;
    top:18px; right:18px;
    z-index:9999;
    display:flex;
    align-items:center;
    gap:56px;
    mix-blend-mode:difference;
    user-select:none;
    -webkit-user-select:none;
  }
  .toplink{
    font-size:22px;
    font-weight:700;
    letter-spacing:.22em;
    text-transform:uppercase;
    white-space:nowrap;
    cursor:pointer;
    color:rgba(255,255,255,.92);
  }
  .toplink.muted{ color:rgba(255,255,255,.72); }

  /* Nodes dropdown */
  .nodes{ position:relative; cursor:default; }
  .nodes-bridge{
    position:absolute; top:100%;
    left:-30px; right:-30px;
    height:28px;
    background:transparent;
    pointer-events:auto;
  }
  .nodes-stack{
    position:absolute;
    top:calc(100% + 18px);
    left:50%;
    transform:translateX(-50%);
    display:grid;
    gap:22px;
    opacity:0;
    pointer-events:none;
    /* no transitions (test mode) */
    z-index:99999;
  }
  .nodes:hover .nodes-stack{
    opacity:1;
    pointer-events:auto;
  }
  .node{
    width:11.5ch;
    text-align:center;
    font-size:40px;
    font-weight:700;
    letter-spacing:.04em;
    opacity:.92;
    cursor:pointer;
    position:relative;
  }
  .node::after{
    content:"";
    position:absolute;
    left:50%;
    bottom:-12px;
    width:0;
    height:2px;
    transform:translateX(-50%);
    background: rgba(255,255,255,.9);
    opacity:.85;
  }
  .node:hover::after{ width:66%; }

  /* Footer fixed in index (outside overlay) */
  .index-footer{
    position:fixed;
    left:0; right:0;
    bottom:18px;
    z-index:9998;
    text-align:center;
    font-size:11px;
    letter-spacing:.14em;
    text-transform:uppercase;
    opacity:.55;
    mix-blend-mode:difference;
    pointer-events:none;
    user-select:none;
    -webkit-user-select:none;
    padding:0 18px;
  }

  /* ===== ABOUT overlay (only opens on click) ===== */
  .about-overlay{
    position:fixed;
    inset:0;
    z-index:2000;
    display:none;
    pointer-events:none;
  }
  .about-overlay.is-open{
    display:block;
    pointer-events:auto;
  }

  /* Keep background visible, just dim slightly (NOT full black) */
  .about-dim{
    position:absolute;
    inset:0;
    background:rgba(0,0,0,.50);
    /* no blur in this test */
  }

  /* Stage: no side padding (edge-to-edge feel) */
  .about-stage{
    position:absolute;
    inset:0;
    display:grid;
    place-items:center;
    padding:min(6vh, 48px) 0;
  }

  /* The ONLY thing that becomes pure black */
  .about-shell{
    position:relative;
    width:100vw;
    max-width:none;
    background:#000;

    border:none;           /* ✅ no borders */
    border-radius:0;       /* ✅ no radius */
    box-shadow:none;       /* ✅ no shadow */
    overflow:hidden;
  }

  /* Premium edge arrows — no transitions */
  .edge-arrow{
    position:absolute;
    top:50%;
    transform:translateY(-50%);
    width:56px;
    height:120px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.04);
    display:grid;
    place-items:center;
    cursor:pointer;
    user-select:none;
    -webkit-user-select:none;

    opacity:0;             /* auto-hide default */
    pointer-events:none;
    z-index:7;
  }
  .edge-arrow.left{ left:18px; }
  .edge-arrow.right{ right:18px; }
  .edge-arrow svg{ width:22px; height:22px; opacity:.9; }

  .about-shell.is-hot .edge-arrow{
    opacity:.9;
    pointer-events:auto;
  }
  .edge-arrow.is-disabled{
    opacity:.18 !important;
    pointer-events:none !important;
  }

  /* Close button — no transitions */
  .about-close{
    position:absolute;
    top:18px; right:18px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.04);
    border-radius:999px;
    padding:10px 14px;
    font-size:12px;
    letter-spacing:.14em;
    text-transform:uppercase;
    color:rgba(255,255,255,.86);
    cursor:pointer;
    z-index:6;
  }

  /* Index indicator */
  .about-index{
    position:absolute;
    left:24px;
    bottom:18px;
    font-size:11px;
    letter-spacing:.14em;
    text-transform:uppercase;
    opacity:.55;
    pointer-events:none;
    z-index:6;
  }

  /* Track & panels */
  .about-track{
    display:flex;
    overflow:hidden;                 /* no drag */
    scroll-snap-type:x mandatory;
    scroll-behavior:smooth;
    touch-action: pan-x;             /* mobile swipe ok */
  }
  .about-panel{
    min-width:100%;
    scroll-snap-align:start;
    padding:56px 0;
    box-sizing:border-box;
  }

  /* Inner content stays centered like your screenshot */
  .about-inner{
    width:min(1180px, calc(100vw - 96px));
    margin:0 auto;
  }

  .about-grid{
    display:grid;
    grid-template-columns: 1.05fr .95fr;
    gap:48px;
    align-items:start;
  }

  .about-media{
    height:min(52vh, 520px);
    border-radius:26px;
    overflow:hidden;
    background:#000;
    border:1px solid rgba(255,255,255,.10);
  }
  .about-media video{ width:100%; height:100%; object-fit:cover; }

  /* DNA canvas (About panel) */
  #dnaCanvas{ width:100%; height:100%; display:block; }

  .about-kicker{
    font-size:12px;
    letter-spacing:.18em;
    text-transform:uppercase;
    opacity:.6;
    margin:0 0 14px;
  }
  .about-title{
    margin:0 0 18px;
    font-size:28px;
    line-height:1.15;
    letter-spacing:.06em;
    text-transform:uppercase;
    color:rgba(255,255,255,.92);
  }
  .about-p{
    margin:0 0 18px;
    font-size:14px;
    line-height:1.65;
    opacity:.72;
    max-width:70ch;
  }
  .about-hr{
    height:1px;
    background:rgba(255,255,255,.10);
    margin:22px 0;
  }

  .about-tags{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    margin-top:10px;
  }
  .about-tag{
    font-size:11px;
    letter-spacing:.14em;
    text-transform:uppercase;
    padding:9px 14px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(255,255,255,.03);
    cursor:pointer;
  }

  @media (max-width: 980px){
    .about-inner{ width:min(1180px, calc(100vw - 44px)); }
    .about-grid{ grid-template-columns:1fr; }
    .about-media{ height:44vh; }

    /* on mobile: arrows always visible */
    .edge-arrow{
      opacity:.92;
      pointer-events:auto;
      height:92px; width:52px;
    }
    .about-shell.is-hot .edge-arrow{
      opacity:.92;
      pointer-events:auto;
    }
  }
</style>
</head>

<body>

<video id="bg" autoplay muted loop playsinline preload="metadata">
  <source src="CT.mp4" type="video/mp4">
</video>

<div class="topbar">
  <div class="toplink muted" id="aboutBtn">ABOUT</div>

  <div class="toplink nodes">NODES
    <div class="nodes-bridge" aria-hidden="true"></div>
    <div class="nodes-stack" aria-hidden="true">
      <div class="node" data-node="001">001</div>
      <div class="node" data-node="002">002</div>
      <div class="node" data-node="003">003</div>
    </div>
  </div>
</div>

<div class="index-footer">
  © 2023–2025 MICRORETAILX LLC · MICROLABSX IS A PROJECT DESIGNATION · NON-COMMERCIAL
</div>

<!-- ABOUT overlay -->
<div class="about-overlay" id="aboutOverlay" aria-hidden="true">
  <div class="about-dim" id="aboutDim"></div>

  <div class="about-stage">
    <div class="about-shell" id="aboutShell" role="dialog" aria-modal="true" aria-label="About panels">

      <button class="about-close" id="aboutClose" type="button">CLOSE</button>

      <div class="edge-arrow left" id="prevBtn" title="Previous">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M14.5 5L8 12l6.5 7" stroke="currentColor" stroke-width="1.9" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>

      <div class="edge-arrow right" id="nextBtn" title="Next">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M9.5 5L16 12l-6.5 7" stroke="currentColor" stroke-width="1.9" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>

      <div class="about-index" id="aboutIndex">01 / 03</div>

      <div class="about-track" id="aboutTrack">

        <section class="about-panel" data-panel="about">
          <div class="about-inner">
            <div class="about-grid">
              <div class="about-media">
                <canvas id="dnaCanvas" aria-label="Interactive DNA strip"></canvas>
              </div>

              <div>
                <div class="about-kicker">ABOUT</div>
                <h2 class="about-title">A GLOBAL, SCALABLE SYSTEM FOR THE NEXT INDUSTRIAL ERA.</h2>

                <p class="about-p">
                  Our objective is to provide governments with a globally deployable and scalable solution based on advanced automation and controlled biotechnology infrastructure.
                </p>

                <div class="about-hr"></div>

                <p class="about-p">
                  The system is designed to transform physical space into fully automated operational environments,
                  aligned with the emerging industrial paradigm where software, robotics, and data orchestration redefine production.
                </p>

                <p class="about-p">
                  By prioritizing automation as a foundational layer, our approach supports efficiency, resilience, and long-term sovereignty across public and institutional deployments.
                </p>

                <div class="about-tags">
                  <span class="about-tag" data-jump="ceo">CEO</span>
                  <span class="about-tag" data-jump="gov">INVESTORS &amp; GOVERNMENTS</span>
                </div>
              </div>
            </div>
          </div>
        </section>

        <section class="about-panel" data-panel="ceo">
          <div class="about-inner">
            <div class="about-kicker">CEO</div>
            <h2 class="about-title">WHO WE ARE</h2>

            <p class="about-p">
              MicroretailX LLC is the legal entity behind this initiative. We develop automation-first systems for controlled, scalable biotech infrastructure across institutional environments.
            </p>

            <div class="about-hr"></div>

            <p class="about-p">
              We focus on the structural layer of the next industrial shift: robotics, software orchestration,
              and measurable execution as a deployable operating system for space.
            </p>
          </div>
        </section>

        <section class="about-panel" data-panel="gov">
          <div class="about-inner">
            <div class="about-kicker">GOVERNMENTS</div>
            <h2 class="about-title">INSTITUTIONAL DEPLOYMENT</h2>

            <p class="about-p">
              A globally deployable framework for public-sector and institutional partners:
              pilot environments, regulatory alignment, operational governance, and long-term resilience.
            </p>

            <div class="about-hr"></div>

            <p class="about-p">
              (When you decide the channel, we embed a minimal institutional contact mechanism here — without exposing unnecessary data.)
            </p>
          </div>
        </section>

      </div>
    </div>
  </div>
</div>

<script>
  const aboutBtn = document.getElementById("aboutBtn");
  const aboutOverlay = document.getElementById("aboutOverlay");
  const aboutDim = document.getElementById("aboutDim");
  const aboutClose = document.getElementById("aboutClose");
  const aboutShell = document.getElementById("aboutShell");

  const track = document.getElementById("aboutTrack");
  const panels = Array.from(track.querySelectorAll(".about-panel"));
  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");
  const indexEl = document.getElementById("aboutIndex");

  function w(){ return track.clientWidth || window.innerWidth; }
  function idx(){ return Math.round(track.scrollLeft / w()); }
  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

  function updateNav(){
    const i = idx();
    indexEl.textContent =
      String(i+1).padStart(2,"0") + " / " + String(panels.length).padStart(2,"0");

    prevBtn.classList.toggle("is-disabled", i === 0);
    nextBtn.classList.toggle("is-disabled", i === panels.length - 1);
  }

  function scrollToIndex(i){
    const target = clamp(i,0,panels.length-1) * w();
    track.scrollTo({ left: target, behavior:"smooth" });
    setTimeout(updateNav, 120);
  }

  function openAbout(panelKey){
    aboutOverlay.classList.add("is-open");
    aboutOverlay.setAttribute("aria-hidden","false");
    document.body.style.overflow = "hidden";

    let i = 0;
    if(panelKey){
      const found = panels.findIndex(p => p.dataset.panel === panelKey);
      i = found >= 0 ? found : 0;
    }
    scrollToIndex(i);
    updateNav();
  }

  function closeAbout(){
    aboutOverlay.classList.remove("is-open");
    aboutOverlay.setAttribute("aria-hidden","true");
    document.body.style.overflow = "";
    aboutShell.classList.remove("is-hot");
  }

  aboutBtn.addEventListener("click", ()=> openAbout("about"));
  aboutDim.addEventListener("click", closeAbout);
  aboutClose.addEventListener("click", closeAbout);

  document.addEventListener("keydown", (e)=>{
    if(!aboutOverlay.classList.contains("is-open")) return;
    if(e.key === "Escape") closeAbout();
    if(e.key === "ArrowLeft") scrollToIndex(idx() - 1);
    if(e.key === "ArrowRight") scrollToIndex(idx() + 1);
  });

  prevBtn.addEventListener("click", ()=> scrollToIndex(idx() - 1));
  nextBtn.addEventListener("click", ()=> scrollToIndex(idx() + 1));

  document.querySelectorAll("[data-jump]").forEach(el=>{
    el.addEventListener("click", ()=>{
      openAbout(el.getAttribute("data-jump"));
    });
  });

  track.addEventListener("scroll", ()=> updateNav(), { passive:true });

  /* Auto-hide arrows: show when cursor near left/right edge of shell */
  let hotT = null;
  function setHot(on){
    aboutShell.classList.toggle("is-hot", on);
    if(on){
      clearTimeout(hotT);
      hotT = setTimeout(()=> aboutShell.classList.remove("is-hot"), 1000);
    }
  }

  aboutShell.addEventListener("mousemove", (e)=>{
    const r = aboutShell.getBoundingClientRect();
    const x = e.clientX - r.left;
    const near = (x < 140) || (x > r.width - 140);
    if(near) setHot(true);
  });
  aboutShell.addEventListener("mouseleave", ()=>{
    aboutShell.classList.remove("is-hot");
  });

  window.addEventListener("resize", ()=>{
    scrollToIndex(idx());
    updateNav();
  });

  updateNav();

  // Nodes click placeholders (keep behavior)
  document.querySelectorAll(".node").forEach(n=>{
    n.addEventListener("click", (e)=> e.stopPropagation());
  });
</script>


<script>
(() => {
  const overlay = document.getElementById("aboutOverlay");
  const track = document.getElementById("aboutTrack");
  const canvas = document.getElementById("dnaCanvas");
  if (!overlay || !track || !canvas) return;

  const ctx = canvas.getContext("2d", { alpha: true });

  // --- resize ---
  let W = 0, H = 0, dpr = 1;
  const DPR = () => Math.min(2, window.devicePixelRatio || 1);
  function resize() {
    const r = canvas.getBoundingClientRect();
    dpr = DPR();
    W = Math.max(1, Math.floor(r.width));
    H = Math.max(1, Math.floor(r.height));
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  // --- pointer ---
  const pointer = { x: 0, y: 0, down: false, has: false, lastX: 0, lastY: 0, lastT: 0, vx: 0, vy: 0 };
  function setPointer(clientX, clientY) {
    const r = canvas.getBoundingClientRect();
    pointer.x = clientX - r.left;
    pointer.y = clientY - r.top;
    pointer.has = true;
  }
  canvas.addEventListener("mousemove", (e) => {
    const now = performance.now();
    setPointer(e.clientX, e.clientY);
    const dt = Math.max(1, now - (pointer.lastT || now));
    pointer.vx = (pointer.x - (pointer.lastX || pointer.x)) / dt;
    pointer.vy = (pointer.y - (pointer.lastY || pointer.y)) / dt;
    pointer.lastX = pointer.x; pointer.lastY = pointer.y; pointer.lastT = now;
  }, { passive: true });
  canvas.addEventListener("mouseleave", () => { pointer.has = false; pointer.down = false; });

  canvas.addEventListener("mousedown", (e) => { setPointer(e.clientX, e.clientY); pointer.down = true; pointer.lastT = performance.now(); });
  window.addEventListener("mouseup", () => { pointer.down = false; });

  canvas.addEventListener("touchstart", (e) => {
    const t = e.touches && e.touches[0]; if (!t) return;
    setPointer(t.clientX, t.clientY);
    pointer.down = true; pointer.lastT = performance.now();
  }, { passive: true });
  canvas.addEventListener("touchmove", (e) => {
    const t = e.touches && e.touches[0]; if (!t) return;
    const now = performance.now();
    setPointer(t.clientX, t.clientY);
    const dt = Math.max(1, now - (pointer.lastT || now));
    pointer.vx = (pointer.x - (pointer.lastX || pointer.x)) / dt;
    pointer.vy = (pointer.y - (pointer.lastY || pointer.y)) / dt;
    pointer.lastX = pointer.x; pointer.lastY = pointer.y; pointer.lastT = now;
  }, { passive: true });
  canvas.addEventListener("touchend", () => { pointer.down = false; pointer.has = false; }, { passive: true });

  // --- panel detection (about / ceo / gov) ---
  function panelKey() {
    const w = track.clientWidth || window.innerWidth;
    const i = Math.round(track.scrollLeft / w);
    const el = track.querySelectorAll(".about-panel")[i];
    const key = el?.getAttribute("data-panel") || "about";
    return (key === "ceo" || key === "gov") ? key : "about";
  }

  // --- helpers ---
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const lerp = (a, b, t) => a + (b - a) * t;

  // --- DNA strip ---
  const N = 120;            // points per strand
  const STEP = 8;           // spacing along strip axis
  const TWIST = 0.28;       // twist per point
  const RUNG_EVERY = 3;

  // break config
  const BREAK_RADIUS = 18;
  const BREAK_FORCE = 2.2;
  const MAX_BROKEN = 40;

  const A = Array.from({ length: N }, () => ({ x: 0, y: 0, tx: 0, ty: 0, z: 0, vx: 0, vy: 0 }));
  const B = Array.from({ length: N }, () => ({ x: 0, y: 0, tx: 0, ty: 0, z: 0, vx: 0, vy: 0 }));

  const rungBroken = new Array(N).fill(false);
  let brokenCount = 0;

  // modes = reorg per panel
  const modes = {
    about: { axis: "vertical", cx: 0.52, cy: 0.50, yaw: 0.35, pitch: 0.10, spin: 0.018 },
    ceo:   { axis: "vertical", cx: 0.48, cy: 0.50, yaw: -0.55, pitch: -0.08, spin: 0.016 },
    gov:   { axis: "horizontal", cx: 0.50, cy: 0.52, yaw: 0.20, pitch: 0.18, spin: 0.014 },
  };

  // palette per panel (premium subtle)
  const palettes = {
    about: { r: 255, g: 255, b: 255 },
    ceo:   { r: 160, g: 210, b: 255 },
    gov:   { r: 190, g: 255, b: 190 },
  };
  const rgba = (c, a) => `rgba(${c.r},${c.g},${c.b},${a})`;

  let current = modes.about;
  let prev = current;
  let targetKey = "about";
  let morph = 1;

  function setMode(key) {
    if (key === targetKey) return;
    prev = current;
    targetKey = key;
    current = modes[key];
    morph = 0;
  }

  function helixTargets(time) {
    const key = panelKey();
    setMode(key);
    morph = Math.min(1, morph + 0.06);

    // blended mode params
    const axis = (morph < 1) ? prev.axis : current.axis;
    const cxp = lerp(prev.cx, current.cx, morph) * W;
    const cyp = lerp(prev.cy, current.cy, morph) * H;
    const yawBase = lerp(prev.yaw, current.yaw, morph);
    const pitchBase = lerp(prev.pitch, current.pitch, morph);
    const spin = lerp(prev.spin, current.spin, morph);

    // pointer influence
    const px = pointer.has ? (pointer.x / Math.max(1, W) - 0.5) * 2 : 0;
    const py = pointer.has ? (pointer.y / Math.max(1, H) - 0.5) * 2 : 0;
    const yaw = yawBase + px * 0.75;
    const pitch = pitchBase + py * 0.45;

    const radius = Math.min(W, H) * 0.18;
    const zScale = 0.55;

    const total = (N - 1) * STEP;
    const start = -total / 2;

    const cosy = Math.cos(yaw), siny = Math.sin(yaw);

    for (let i = 0; i < N; i++) {
      const s = start + i * STEP;
      const a = time + i * TWIST;

      const x = Math.cos(a) * radius;
      const z = Math.sin(a);

      const xA = x, zA = z;
      const xB = -x, zB = -z;

      // yaw rotation with faux depth
      const xAy = xA * cosy - (zA * radius * zScale) * siny;
      const zAy = xA * siny + (zA * radius * zScale) * cosy;

      const xBy = xB * cosy - (zB * radius * zScale) * siny;
      const zBy = xB * siny + (zB * radius * zScale) * cosy;

      const yAp = (zAy / (radius || 1)) * pitch * 22;
      const yBp = (zBy / (radius || 1)) * pitch * 22;

      if (axis === "horizontal") {
        A[i].tx = cxp + s;
        A[i].ty = cyp + xAy + yAp;
        B[i].tx = cxp + s;
        B[i].ty = cyp + xBy + yBp;
      } else {
        A[i].tx = cxp + xAy;
        A[i].ty = cyp + s + yAp;
        B[i].tx = cxp + xBy;
        B[i].ty = cyp + s + yBp;
      }

      A[i].z = clamp(zAy / (radius || 1), -1, 1);
      B[i].z = clamp(zBy / (radius || 1), -1, 1);
    }

    return { spin, key };
  }

  function alphaFromZ(z) { return 0.10 + 0.24 * ((z + 1) * 0.5); }
  function sizeFromZ(z) { return 1.2 + 1.8 * ((z + 1) * 0.5); }

  function tryBreak() {
    if (!pointer.down) return;
    if (brokenCount >= MAX_BROKEN) return;

    let bestI = -1;
    let bestD = 1e9;

    for (let i = 0; i < N; i += RUNG_EVERY) {
      if (rungBroken[i]) continue;
      const mx = (A[i].x + B[i].x) / 2;
      const my = (A[i].y + B[i].y) / 2;
      const d = Math.hypot(mx - pointer.x, my - pointer.y);
      if (d < bestD) { bestD = d; bestI = i; }
    }

    if (bestI >= 0 && bestD < BREAK_RADIUS) {
      rungBroken[bestI] = true;
      brokenCount++;

      const i = bestI;
      const dx = A[i].x - B[i].x;
      const dy = A[i].y - B[i].y;
      const len = Math.hypot(dx, dy) || 1;
      const nx = dx / len, ny = dy / len;

      const imp = BREAK_FORCE + (Math.abs(pointer.vx) + Math.abs(pointer.vy)) * 18;

      for (let k = -4; k <= 4; k++) {
        const j = i + k;
        if (j < 0 || j >= N) continue;
        const fall = 1 - Math.abs(k) / 5;
        A[j].vx += nx * imp * fall;
        A[j].vy += ny * imp * fall;
        B[j].vx -= nx * imp * fall;
        B[j].vy -= ny * imp * fall;
      }
    }
  }

  function stepPhysics() {
    const SPRING = 0.18;
    const DAMP = 0.86;

    for (let i = 0; i < N; i++) {
      const pa = A[i];
      const pb = B[i];

      pa.vx = (pa.vx + (pa.tx - pa.x) * SPRING) * DAMP;
      pa.vy = (pa.vy + (pa.ty - pa.y) * SPRING) * DAMP;
      pa.x += pa.vx; pa.y += pa.vy;

      pb.vx = (pb.vx + (pb.tx - pb.x) * SPRING) * DAMP;
      pb.vy = (pb.vy + (pb.ty - pb.y) * SPRING) * DAMP;
      pb.x += pb.vx; pb.y += pb.vy;
    }
  }

  function render(color) {
    ctx.clearRect(0, 0, W, H);

    // backbones
    ctx.lineWidth = 1;
    ctx.strokeStyle = rgba(color, 0.14);

    ctx.beginPath();
    for (let i = 0; i < N; i++) {
      const p = A[i];
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.beginPath();
    for (let i = 0; i < N; i++) {
      const p = B[i];
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    // rungs (skip broken)
    for (let i = 0; i < N; i += RUNG_EVERY) {
      if (rungBroken[i]) continue;
      const p = A[i], q = B[i];
      const za = (p.z + q.z) * 0.5;
      const a = 0.08 + 0.12 * ((za + 1) * 0.5);
      ctx.strokeStyle = rgba(color, a);
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(q.x, q.y);
      ctx.stroke();
    }

    // nodes (depth sort)
    const pts = [];
    for (let i = 0; i < N; i++) {
      pts.push({ x: A[i].x, y: A[i].y, z: A[i].z });
      pts.push({ x: B[i].x, y: B[i].y, z: B[i].z });
    }
    pts.sort((p, q) => p.z - q.z);

    for (const p of pts) {
      const a = alphaFromZ(p.z);
      const s = sizeFromZ(p.z);
      ctx.fillStyle = rgba(color, a);
      ctx.beginPath();
      ctx.arc(p.x, p.y, s, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // --- run loop only when overlay open ---
  let running = false, raf = null, t = 0;

  function start() {
    if (running) return;
    running = true;
    resize();

    // init to targets (no jump)
    const out = helixTargets(t);
    for (let i = 0; i < N; i++) {
      A[i].x = A[i].tx; A[i].y = A[i].ty; A[i].vx = 0; A[i].vy = 0;
      B[i].x = B[i].tx; B[i].y = B[i].ty; B[i].vx = 0; B[i].vy = 0;
    }
    raf = requestAnimationFrame(loop);
  }

  function stop() {
    running = false;
    if (raf) cancelAnimationFrame(raf);
    raf = null;
    ctx.clearRect(0, 0, W, H);
  }

  function loop() {
    if (!running) return;

    const { spin, key } = helixTargets(t);
    const color = palettes[key] || palettes.about;

    tryBreak();
    stepPhysics();
    render(color);

    t += spin;
    raf = requestAnimationFrame(loop);
  }

  // observe overlay open/close
  const obs = new MutationObserver(() => {
    const open = overlay.classList.contains("is-open");
    if (open) start();
    else stop();
  });
  obs.observe(overlay, { attributes: true, attributeFilter: ["class"] });

  // resize
  window.addEventListener("resize", () => {
    if (!running) return;
    resize();
  });
})();
</script>

</body>
</html>
